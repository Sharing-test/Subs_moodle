WEBVTT



00:00:00.210 --> 00:00:04.019
Welcome my friend to today's
lecture on computer language.

00:00:04.470 --> 00:00:10.020
Let's unpack the mystery of this concept
without needing a PhD or a panic attack.

00:00:10.560 --> 00:00:14.790
So what is this whole drama
about computer languages array?

00:00:14.790 --> 00:00:16.050
It's very simple.

00:00:16.440 --> 00:00:20.490
A computer language is just a
set of instructions, commands,

00:00:20.640 --> 00:00:25.140
and syntax that a programmer uses
to communicate with a computer.

00:00:25.564 --> 00:00:30.755
Just like we humans use languages like
English or Hindi to talk to each other.

00:00:31.084 --> 00:00:36.305
Computers need their own special languages
to understand what we want them to do.

00:00:36.665 --> 00:00:38.165
They can't understand our,

00:00:40.205 --> 00:00:46.025
these languages are absolutely essential
because computers are a bit simple-minded.

00:00:46.415 --> 00:00:51.364
They only understand electrical
signals on or off, which we represent

00:00:51.364 --> 00:00:53.194
as the famous ones and zeros.

00:00:53.995 --> 00:00:58.315
Computer languages brilliantly bridge
the massive gap between our human

00:00:58.315 --> 00:01:00.175
instructions and the machine's.

00:01:00.175 --> 00:01:02.035
Basic binary understanding.

00:01:02.605 --> 00:01:06.985
There are primarily three types of
these languages you need to know about.

00:01:07.465 --> 00:01:11.545
First, we have machine language,
which is a low level language.

00:01:11.905 --> 00:01:16.375
This is the most fundamental language
a computer understands directly.

00:01:16.465 --> 00:01:18.295
Its absolute mother tongue.

00:01:18.655 --> 00:01:23.335
It consists entirely of binary
digits, just zeros and ones.

00:01:23.690 --> 00:01:29.630
Believe me, it is very, very difficult for
humans to read, write, or find a mistake

00:01:29.690 --> 00:01:32.720
to debug any program in machine language.

00:01:33.080 --> 00:01:36.740
It's like a long, long, boring
sequence of binary codes.

00:01:37.070 --> 00:01:42.289
To make things even more complicated, each
type of computer processor has its own

00:01:42.289 --> 00:01:45.020
unique machine language, a real headache.

00:01:45.535 --> 00:01:48.955
Next is assembly language,
another low level language.

00:01:49.285 --> 00:01:53.785
This is a good step up from the pure
madness of machine language instead

00:01:53.785 --> 00:01:58.945
of just binary codes, it uses symbolic
instruction codes called mnemonics.

00:01:59.245 --> 00:02:01.345
Think of them as nicknames like.

00:02:01.605 --> 00:02:06.554
A DD for addition, MOV for
move, or SUB for subtraction.

00:02:06.854 --> 00:02:11.025
While it is still very much machine
dependent, it's much easier for

00:02:11.025 --> 00:02:15.195
us humans to understand and write
compared to that binary mess.

00:02:15.495 --> 00:02:20.055
However, programs written in assembly
language need a special translator,

00:02:20.204 --> 00:02:24.675
A helper called an assembler to
convert them into machine language.

00:02:24.925 --> 00:02:29.815
And finally, the rock stars of the
programming world high level language.

00:02:30.235 --> 00:02:34.765
These languages are designed to be
much more human friendly and are closer

00:02:34.765 --> 00:02:36.865
to natural languages like English.

00:02:37.285 --> 00:02:41.785
They use familiar words, mathematical
symbols, and logical structures,

00:02:41.995 --> 00:02:46.105
making them significantly easier
to learn, write, and debug.

00:02:46.585 --> 00:02:48.475
You have definitely heard their names.

00:02:48.770 --> 00:02:54.560
Python, Java, c plus plus and C.
Programs written in high level languages

00:02:54.560 --> 00:02:59.300
are portable, meaning they can run on
different types of computers with just

00:02:59.300 --> 00:03:04.970
minimal changes, but they do require a
compiler or an interpreter to translate

00:03:04.970 --> 00:03:09.260
them into machine language before the
computer can finally execute them.

00:03:09.590 --> 00:03:10.460
Translators.

00:03:10.790 --> 00:03:13.490
Now let's focus on these translators.

00:03:13.700 --> 00:03:15.265
They are the unsung heroes.

00:03:15.885 --> 00:03:18.885
An assembler is a program
that does one job.

00:03:19.065 --> 00:03:23.055
It translates assembly language
code into machine language simple.

00:03:23.535 --> 00:03:28.455
A compiler is a program that translates
an entire high level language program

00:03:28.575 --> 00:03:33.135
into machine code or what we call
object code before the program is

00:03:33.135 --> 00:03:35.505
executed if there are any errors.

00:03:35.625 --> 00:03:39.225
The compiler is like a strict
teacher who lists all of them

00:03:39.225 --> 00:03:41.325
at once, and the big advantage.

00:03:41.675 --> 00:03:44.705
Compiled programs
generally run much faster.

00:03:45.125 --> 00:03:46.685
Then we have the interpreter.

00:03:47.075 --> 00:03:52.055
This program translates and executes a
high level language program line by line.

00:03:52.385 --> 00:03:56.555
If it finds an error, it stops
execution right there at that line

00:03:56.705 --> 00:03:59.075
and complains for this reason.

00:03:59.225 --> 00:04:04.145
Interpreted programs are generally slower,
but they are often much easier to debug.

00:04:04.475 --> 00:04:05.765
Real world relevance.

00:04:06.155 --> 00:04:09.875
Now you might be asking, sir,
why should I care about all this?

00:04:10.084 --> 00:04:14.795
Well, my friend, understanding computer
languages is crucial for many aspects

00:04:14.795 --> 00:04:17.104
of modern operations and data handling.

00:04:17.464 --> 00:04:19.445
First software interaction.

00:04:19.774 --> 00:04:24.664
These languages form the very basis of
all software enabling our interaction

00:04:24.664 --> 00:04:27.005
with countless applications and systems.

00:04:27.395 --> 00:04:31.085
This knowledge helps in using and
troubleshooting your digital tools.

00:04:31.445 --> 00:04:33.215
Then there's data processing.

00:04:33.590 --> 00:04:37.730
Many data analysis and processing
tasks rely on scripts written

00:04:37.730 --> 00:04:39.320
in various computer languages.

00:04:39.620 --> 00:04:43.730
Familiarity with them helps you
comprehend how data is manipulated

00:04:43.820 --> 00:04:45.920
and how insights are derived from it.

00:04:46.190 --> 00:04:48.470
And what about automation of tasks?

00:04:48.800 --> 00:04:52.040
Repetitive tasks can often
be automated using programs

00:04:52.040 --> 00:04:53.695
written in specific languages.

00:04:54.400 --> 00:04:58.570
This streamlines workflows and improves
efficiency in daily operations.

00:04:58.780 --> 00:05:02.290
This knowledge also sharpens
your security awareness.

00:05:02.620 --> 00:05:07.390
A basic understanding of how software is
built can help in recognizing potential

00:05:07.390 --> 00:05:12.700
vulnerabilities or understanding security
protocols, which contributes to a more

00:05:12.700 --> 00:05:14.650
secure digital environment for you.

00:05:15.140 --> 00:05:17.780
It also leads to better
system understanding.

00:05:18.260 --> 00:05:22.670
Knowing about different language types
helps in grasping how various computer

00:05:22.670 --> 00:05:25.130
systems and their components communicate.

00:05:25.550 --> 00:05:30.560
This is absolutely key for effective
system management and perhaps

00:05:30.560 --> 00:05:34.190
most importantly, it improves
your problem solving skills.

00:05:34.575 --> 00:05:38.235
The logical thinking fostered by
understanding computer languages

00:05:38.415 --> 00:05:42.705
is transferable to solving complex
problems in any professional setting.

00:05:43.095 --> 00:05:46.185
It truly enhances your
analytical capabilities.

00:05:47.100 --> 00:05:51.540
Breakdown of question types based
on what you can expect in your exam.

00:05:51.750 --> 00:05:55.890
Questions on computer language often
fall into a few key categories.

00:05:56.310 --> 00:06:01.230
A large portion about 40% will be
definition identification questions.

00:06:01.750 --> 00:06:06.670
These ask you to define terms like
compiler, interpreter, or identify

00:06:06.670 --> 00:06:08.680
examples of high level languages.

00:06:09.099 --> 00:06:13.690
About 30% of questions are on
differences, comparisons, where you'll

00:06:13.690 --> 00:06:17.890
need to compare and contrast machine
versus assembly language, or the

00:06:17.890 --> 00:06:19.870
classic compiler versus interpret.

00:06:20.450 --> 00:06:24.109
Around 15% of questions will
be about purpose function.

00:06:24.440 --> 00:06:28.789
Asking about the role of an assembler or
why high level languages are preferred,

00:06:29.239 --> 00:06:32.299
a smaller 10% will be on characteristics.

00:06:32.510 --> 00:06:36.770
Testing your knowledge of features
like machine dependency or readability.

00:06:37.160 --> 00:06:42.140
And finally, about 5% of questions
are simple examples, asking you

00:06:42.140 --> 00:06:46.580
to identify a specific language
type formulas and tricks.

00:06:46.910 --> 00:06:51.350
While this topic is more conceptual,
here are the key distinctions and points

00:06:51.350 --> 00:06:53.660
you must memorize for machine language.

00:06:54.215 --> 00:06:59.375
Think binary, zeros, and ones directly
understood by the CPU hardware

00:06:59.375 --> 00:07:01.655
dependent and difficult for humans.

00:07:02.045 --> 00:07:07.355
For assembly language, think mnemonics
like add sub needs, and assembler.

00:07:07.565 --> 00:07:11.195
Also, hardware dependent easier
than machine code, but harder

00:07:11.195 --> 00:07:12.485
than high level languages.

00:07:12.935 --> 00:07:17.885
For high level language, think English
like needs a compiler or an interpreter.

00:07:18.095 --> 00:07:19.565
Is hardware independent?

00:07:19.625 --> 00:07:22.355
That means portable and easy for humans.

00:07:22.734 --> 00:07:23.934
For the translators.

00:07:24.025 --> 00:07:28.945
Remember, a compiler translates the
entire program at once, finds all

00:07:28.945 --> 00:07:33.715
errors at once, creates an executable
and results in faster execution.

00:07:34.044 --> 00:07:38.094
An interpreter translates line by
line, stops at the first error,

00:07:38.304 --> 00:07:41.575
doesn't create a separate executable,
and is slower in execution.

00:07:42.330 --> 00:07:46.770
And the big rule, low level languages
are machine and assembly because

00:07:46.770 --> 00:07:48.179
they are closer to the hardware.

00:07:48.390 --> 00:07:52.080
High level languages are all the
others because they are closer to

00:07:52.080 --> 00:07:57.960
human language methods of solving for
questions related to computer languages.

00:07:58.109 --> 00:08:00.570
A systematic approach always helps.

00:08:01.000 --> 00:08:05.680
First, understand the core concept
before attempting any question.

00:08:05.860 --> 00:08:10.330
Ensure you have a clear understanding
of each type of language and

00:08:10.390 --> 00:08:12.219
what each translator does.

00:08:12.669 --> 00:08:14.770
Then identify keywords.

00:08:15.130 --> 00:08:16.840
Look for clues in the question.

00:08:17.169 --> 00:08:19.835
Binary code should make you
think of machine language.

00:08:20.490 --> 00:08:24.240
Mnemonics points to assembly
language line by line.

00:08:24.240 --> 00:08:28.350
Execution means interpreter
and entire program.

00:08:28.350 --> 00:08:30.540
Translation screams, compiler.

00:08:30.990 --> 00:08:36.480
Also be ready to compare and contrast
if the question asks for differences,

00:08:36.630 --> 00:08:41.820
mentally list the key characteristics of
the two things being compared, like their

00:08:41.820 --> 00:08:44.405
speed, error, reporting or portability.

00:08:45.065 --> 00:08:48.445
Always relate to hardware
for low level languages.

00:08:48.815 --> 00:08:52.655
Remember that direct dependence
on specific computer hardware

00:08:53.015 --> 00:08:54.485
for high level languages.

00:08:54.605 --> 00:08:58.805
Recall their wonderful abstraction
from the hardware, and finally

00:08:58.925 --> 00:09:00.635
have a functionality focus.

00:09:00.965 --> 00:09:06.245
When asked about a translator, just focus
on its primary function, converting one

00:09:06.245 --> 00:09:09.335
form of code into another for execution.

00:09:10.500 --> 00:09:12.570
Shortcuts and smart techniques.

00:09:12.930 --> 00:09:15.300
Okay, time for some smart techniques.

00:09:15.630 --> 00:09:20.250
If you see zeros and ones mentioned
immediately, think machine language.

00:09:20.640 --> 00:09:24.930
If you see add, sub move, you
know those are mnemonics, the

00:09:24.930 --> 00:09:26.700
hallmark of assembly language.

00:09:27.140 --> 00:09:31.970
If a question lists Python, Java, c
plus plus, you know, these are common

00:09:31.970 --> 00:09:33.860
examples of high level languages.

00:09:34.190 --> 00:09:38.840
Here's a memory trick, think
C for compiler and C for

00:09:38.840 --> 00:09:40.640
complete program translation.

00:09:40.970 --> 00:09:46.250
And I, for interpreter and I for
immediate line by line execution.

00:09:46.610 --> 00:09:50.600
Remember the portability rule,
high level languages are generally

00:09:50.600 --> 00:09:54.590
portable, low level languages
are not, and the speed rule.

00:09:54.935 --> 00:09:59.405
Compiled programs are faster interpreted
programs are generally slower.

00:10:00.030 --> 00:10:02.430
Common mistakes and misconceptions.

00:10:03.150 --> 00:10:06.930
Now pay attention to the
common traps you must avoid.

00:10:07.470 --> 00:10:09.900
A very common error is confusing.

00:10:09.900 --> 00:10:11.940
Compiler and interpreter.

00:10:12.510 --> 00:10:17.105
Remember, there are different methods,
whole program versus line by line.

00:10:17.569 --> 00:10:23.420
And how they report errors also
don't fall for the idea that all

00:10:23.420 --> 00:10:25.880
high level languages are interpreted.

00:10:26.420 --> 00:10:31.400
Many like c and c plus plus
are compiled while others like

00:10:31.430 --> 00:10:33.740
Python are typically interpreted.

00:10:34.130 --> 00:10:36.860
Some like Java use a
clever hybrid approach.

00:10:38.160 --> 00:10:43.079
Another mistake is thinking machine
language is easy to write while the

00:10:43.079 --> 00:10:48.930
machine understands it, it's extremely
difficult for humans, and please do not

00:10:48.960 --> 00:10:51.600
assume assembly language is high level.

00:10:52.050 --> 00:10:56.970
It is a low level language because it
is still very close to the hardware.

00:10:57.390 --> 00:11:00.135
Finally, try to remember
the language generations.

00:11:00.845 --> 00:11:02.975
First gen is machine language.

00:11:03.125 --> 00:11:08.405
Second gen is assembly language, and
third gen is for high level languages.

00:11:09.405 --> 00:11:11.205
WH framework summary.

00:11:11.655 --> 00:11:17.025
So to summarize everything very
quickly, what are computer languages?

00:11:17.325 --> 00:11:22.665
They are sets of instructions that allow
humans to communicate with computers.

00:11:22.995 --> 00:11:24.135
Why are they needed?

00:11:24.530 --> 00:11:29.420
They are essential to convert human
readable instructions into a format.

00:11:29.600 --> 00:11:32.270
Computers can understand and execute.

00:11:32.690 --> 00:11:33.860
When are they applied?

00:11:34.190 --> 00:11:39.560
Whenever developing any software from
operating systems to mobile apps and

00:11:39.560 --> 00:11:44.990
websites, where are they used in all
computing environments, including personal

00:11:44.990 --> 00:11:47.840
computers, servers, and mobile devices.

00:11:48.165 --> 00:11:49.155
Who uses them?

00:11:49.425 --> 00:11:53.594
Programmers, software developers,
and computer scientists use them.

00:11:53.895 --> 00:11:55.064
And how does it work?

00:11:55.365 --> 00:12:00.915
Instructions are written then translated
by an assembler, compiler, or interpreter

00:12:01.064 --> 00:12:03.135
into machine code for execution.

00:12:04.080 --> 00:12:05.880
Fully worked out examples.

00:12:06.210 --> 00:12:07.860
All right, enough theory.

00:12:08.040 --> 00:12:09.600
Let's solve some questions.

00:12:10.020 --> 00:12:11.939
Example, one question.

00:12:12.300 --> 00:12:16.560
Which of the following statements
is true regarding machine language?

00:12:16.949 --> 00:12:21.689
A, it uses English like statements
and is easy for humans to understand.

00:12:21.970 --> 00:12:27.939
B, it requires an interpreter to
convert it into binary code C. It is

00:12:27.939 --> 00:12:32.650
directly understood and executed by
the computer's central processing unit.

00:12:32.860 --> 00:12:34.330
CPUD.

00:12:34.660 --> 00:12:38.380
It is highly portable across
different types of computer hardware.

00:12:38.860 --> 00:12:41.405
Understand the question
before moving to explanation.

00:12:42.720 --> 00:12:43.830
Let's break it down.

00:12:44.160 --> 00:12:47.880
The question asks for a true
statement about machine language.

00:12:48.330 --> 00:12:51.330
Option A says, it's English like and easy.

00:12:51.570 --> 00:12:52.500
This is false.

00:12:52.620 --> 00:12:55.470
It uses binary and is
very hard for humans.

00:12:55.770 --> 00:12:58.350
Option B says it needs an interpreter.

00:12:58.650 --> 00:12:59.490
This is false.

00:12:59.640 --> 00:13:01.170
It's already in binary.

00:13:01.350 --> 00:13:04.980
It is the destination language
for translators, not the source.

00:13:05.345 --> 00:13:08.825
Option C says it's directly
understood by the CPU.

00:13:09.155 --> 00:13:11.255
This is the definition
of machine language.

00:13:11.435 --> 00:13:14.735
The CPU's native tongue, so C is true.

00:13:15.095 --> 00:13:17.345
Option D says, it's highly portable.

00:13:17.615 --> 00:13:18.635
This is false.

00:13:18.755 --> 00:13:22.805
It's specific to a processes
architecture, and not portable at all.

00:13:23.135 --> 00:13:27.225
Correct answer c. Example two question.

00:13:27.555 --> 00:13:31.455
A software that translates an
entire program written in a high

00:13:31.455 --> 00:13:35.805
level language into machine code
before execution is known as A.

00:13:36.075 --> 00:13:37.245
A assembler.

00:13:37.485 --> 00:13:38.805
B interpreter.

00:13:38.985 --> 00:13:44.925
C compiler, D debugger understand the
question before moving to explanation.

00:13:45.780 --> 00:13:47.040
Let's analyze this.

00:13:47.400 --> 00:13:50.819
The question describes a
translator for an entire high

00:13:50.819 --> 00:13:52.829
level program before execution.

00:13:53.189 --> 00:13:54.959
Let's recall our definitions.

00:13:55.290 --> 00:13:57.900
An assembler is for assembly language.

00:13:58.140 --> 00:14:00.840
An interpreter translates line by line.

00:14:00.840 --> 00:14:04.800
During execution, a compiler
translates an entire high

00:14:04.800 --> 00:14:06.360
level program before execution.

00:14:07.135 --> 00:14:11.844
A debugger is for finding errors,
not translating the description

00:14:11.964 --> 00:14:16.495
translates an entire program
before execution is a perfect match

00:14:16.495 --> 00:14:18.329
for a compiler correct answer.

00:14:18.810 --> 00:14:21.765
C. Example three question.

00:14:22.064 --> 00:14:25.665
Which of the following is a
characteristic of assembly language?

00:14:26.025 --> 00:14:29.745
A. It is the fastest language
for humans to write programs.

00:14:29.925 --> 00:14:36.255
B, it uses mnemonics for instructions and
requires an assembler C. It is completely

00:14:36.255 --> 00:14:38.595
machine independent and highly portable.

00:14:38.865 --> 00:14:42.615
D errors are reported line
by line during execution.

00:14:43.064 --> 00:14:45.824
Understand the question
before moving to explanation.

00:14:46.740 --> 00:14:50.250
Okay, we need a characteristic
of assembly language.

00:14:50.670 --> 00:14:53.640
Option A says it's fastest
for humans to write.

00:14:53.880 --> 00:14:57.060
False high level languages
are the fastest for humans.

00:14:57.390 --> 00:15:01.170
Option B says it uses mnemonics
and needs and assembler.

00:15:01.500 --> 00:15:04.410
This is the exact definition
of assembly language.

00:15:04.710 --> 00:15:09.210
It uses codes like add and sub and
needs an assembler for translation.

00:15:09.454 --> 00:15:10.985
So B is true.

00:15:11.345 --> 00:15:15.574
Option C says it is machine
independent and portable false.

00:15:15.694 --> 00:15:18.454
It is highly machine
dependent and not portable.

00:15:18.814 --> 00:15:22.925
Option D says errors are reported
line by line during execution.

00:15:23.225 --> 00:15:27.095
That's the job of an interpreter,
which works with high level languages.

00:15:27.215 --> 00:15:31.475
So D is false, correct
answer B. Thank you.

00:15:31.564 --> 00:15:33.035
See you in the next lecture.

